;
; 4816 (and 4132 half-qualified chips) Test Program
;

; Pin Assignments
; SP0,  A0,  5,  output, out
; SP1,  A1,  6,  output, out
; SP2,  A2,  7,  output, out
; SP3,  A3,  8,  output, out
; SP4,  A4,  9,  output, out
; SP5,  A5,  10, output, out
; SP6,  A6,  11, output, out
; SP7,  nc,  12, output, out
; SP8,  nc,  13, output, out
; SP9,  D,   14, output, out
; SP10, WE,  15, output, set
; SP11, RAS, 16, output, set
; SP12, CAS, 17, output, set
; SP13, nc,  18, na,     na
; SP14, nc,  19, na,     na
; SP15, nc,  20, na,     na
; SP16, Q,   21, input,  in

; Timing values (nameplate, tRAC): 100ns, 120ns, 150ns, 200ns, 300ns
; set pins: CAS, RAS, WR.

.pio_version 0 // only requires PIO version 0
.program ram4816

; Notes:
; We need to update the address lines and the RAS at the same time.
; All current C bindings disable fast page mode. So the the fast page code
; path below is not currently used.
;
; The write pulse starts at the same time as CAS is brought low. Making this
; a "Late Write" cycle. This is very similar to the read-modify-write
; cycle except that the timing parameters, tRWD and tCWD, are not
; necessarily met. The state of data-out is indeterminate since the
; output pin could be either Hi-Z (effectivley disconnected) or contain
; data depending on the timing conditions. 
; tVALUES and timings calculated below are for 100ns chip and its delays.

main:
    jmp begin
full_transfer:            ; 
    nop [1]               ; Wait [1]
    nop [2]               ; Wait [2]
    out pins, 8           ; Set the row address
    set pins, 0b101       ; Lower RAS. tRP must be met. Start of tRAC, tRAH, tRAS, tRCD and tWCR timings.
    nop [3]               ; Wait [3]
cas_only_transfer:
    out pins, 10          ; Set the column address and data bit. Setting the data bit now allows for early and late write scenarios. tRAH must be met.
    jmp !x skip_wr        ; Write... or don't...We make sure that the branching paths take the same time.
    set pins, 0b000       ; Lower WR and CAS Start of tWP and tWCH and tCAS. tCPN must be met. If we factor in transition timings, we are perhaps now in Late Write mode with indeterminate data out.
    jmp skip_wr2           ; Jump back to shared codepath.
skip_wr:
    set pins, 0b001       ; Lower CAS Start of tCAH and tCAS. tRCD(min) and tCPN must be met. tRCD(max) must not (so that tRAC determines data availability later).
    nop                   ; Ensure that both branches take the same amount of time.
skip_wr2:
    mov OSR, NULL         ; Blank the State Machine's Output Shift Register.
    nop [4]               ; Wait [4]
    set pins, 0b001       ; Raise WR. tWP, tWCH and tWCR must be met.
    out pins, 10          ; Clear column address and the write bit (we're OUTing all zeros to the pins). tCAH must be met for read cycles.
    nop [5]               ; Wait [5]
    in pins, 1            ; Read the read data bit into the OSR. tRAC must be met. In our configured write mode, Q will be garbage.
    set pins, 0b101       ; Raise CAS. tCAS must be met.
    push noblock          ; 
    nop [6]               ; Wait [6]
    jmp !y begin          ; tRAS and tRC must have been met.
    jmp skip_ras          ; 
begin:
    set pins, 0b111       ; Raise RAS, CAS & WR.  tRP and tCPN
skip_ras:
    pull block            ; 
    out y, 1              ;  
    out x, 1              ; 
    jmp !y full_transfer  ; 
    out NULL, 8 [7]       ; Wait [7]
    jmp cas_only_transfer ;


% c-sdk {
// Original delay numbers are 27, 5, 3, 13, 9
#define RAM4816_DELAYS 3
#define RAM4816_DELAY_FIELDS 8
                                             //0   1   2  3   4   5   6   7
static const uint8_t ram4816_delays[3][32] = {{0,  0, 26, 4,  8,  6,  3,  0},    // 100ns
                                              {0,  0, 29, 4, 13,  7,  4,  0},    // 120ns
                                              {0,  0, 34, 4, 22,  7,  5,  0} };  // 150ns

static inline void ram4816_program_init(PIO pio, uint sm, uint offset, uint pin) {
    uint count;

    // Set up 17 total pins
    for (count = 0; count < 17; count++) {
        pio_gpio_init(pio, pin + count);
        gpio_set_slew_rate(pin + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(pin + count, GPIO_DRIVE_STRENGTH_4MA);
    }
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 13, true); // true=output
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 16, 1, false); // input

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = ram4816_program_get_default_config(offset);

    // A0, A1, A2, A3, A4, A5, A6, A7(nc), nc, D, WR, RAS, CAS, nc, nc, nc, IN
    sm_config_set_out_pins(&c, pin, 10);
    sm_config_set_set_pins(&c, pin + 10, 3); // Max is 5.
    sm_config_set_in_pins(&c, pin + 16);

    // Shift right, Autopull off, 20 bits (1 + 1 + 8 + 10) at a time
    sm_config_set_out_shift(&c, true, false, 20);
    // Shift left, Autopull on, 1 bit
    sm_config_set_in_shift(&c, false, false, 1);

 //   hw_set_bits(&pio->input_sync_bypass, 1u << pin); to bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Routines for reading and writing memory through the FIFOs
int ram4816_ram_read(int addr)
{
    uint d;
    pio_sm_put(pio, sm, 0 |                     // Fast page mode flag
                        0 << 1 |                // Write flag
                        (addr & 0x7f) << 2 |  // Row address
                        (addr >> 7) << 10  |    // Column address
                        ((0 & 1) << 19));       // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    d = pio_sm_get(pio, sm);                    // Return the data
    //gpio_put(GPIO_LED, d);
    return d;
}

void ram4816_ram_write(int addr, int data)
{
    pio_sm_put(pio, sm, 0 |                     // Fast page mode flag
                        1 << 1 |                // Write flag
                        (addr & 0x7f) << 2 |  // Row address
                        (addr >> 7 ) << 10 |    // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

// Routines to set up and tear down the PIO program (and the RAM test)
void ram4816_setup_pio(uint speed_grade, uint variant)
{
    uint pin = 5;
    set_current_pio_program(&ram4816_program);
    // Patches the program with the correct delay values
    pio_patch_delays(ram4816_delays[speed_grade], RAM4816_DELAY_FIELDS);
    bool rc = pio_claim_free_sm_and_add_program_for_gpio_range(get_current_pio_program(), &pio, &sm, &offset, pin, 17, true);
    ram4816_program_init(pio, sm, offset, pin);
    pio_sm_set_enabled(pio, sm, true);
}

void ram4816_teardown_pio()
{
    pio_sm_set_enabled(pio, sm, false);
    pio_remove_program_and_unclaim_sm(&ram4816_program, pio, sm, offset);
}

// This RAM chip configuration
static const mem_chip_t ram4816_chip = { .setup_pio = ram4816_setup_pio,
                                          .teardown_pio = ram4816_teardown_pio,
                                          .ram_read = ram4816_ram_read,
                                          .ram_write = ram4816_ram_write,
                                          .mem_size = 16384,
                                          .bits = 1,
                                          .variants = NULL,
                                          .speed_grades = RAM4816_DELAYS,
                                          .chip_name = "4816 (16Kx1 use 4164skt)",
                                          .speed_names = {"100ns", "120ns", "150ns", "200ns", "250ns", "300ns"} };


%}
